module Oscar { export interface IOscarObserverListener { onSuccess() : void; onFail(error? : Error) : void; } }module Oscar { export class OscarObserver implements IOscarObserver { private _isStopped : boolean; private _listener : Oscar.IOscarObserverListener; constructor(listener : Oscar.IOscarObserverListener) { this._listener = listener; this._isStopped = false; } success() : void { if (!this._isStopped) { setTimeout( () => { if (!this._isStopped) { this._isStopped = true; this._listener.onSuccess(); } }, 0 ); } } fail(error? : Error) : void { if (!this._isStopped) { setTimeout( () => { if (!this._isStopped) { this._isStopped = true; this._listener.onFail(error); } }, 0 ); } } stop() : void { this._isStopped = true; } } }module Oscar { export class TestClass { private _core : UnitTestClass; private _methods : Array<TestMethod>; constructor(core : UnitTestClass) { this._core = core; this._methods = new Array<TestMethod>(); } getName() : string { return <string> (<any> this._core).constructor.name; } getCore() : UnitTestClass { return this._core; } addMethod(value : TestMethod) : TestClass { this._methods.push(value); return this; } getMethods() : Array<TestMethod> { return this._methods; } } }module Oscar { export class TestMethod { private _name : string; private _core : () => void; private _isAsync : boolean; private _observer : Oscar.OscarObserver; private _success : boolean; private _error : Error; private _time : number; constructor(name : string, core : () => void, isAsync : boolean = false) { this._name = name; this._core = core; this._isAsync = isAsync; } getName() : string { return this._name; } getCore() : () => void { return this._core; } isAsync() : boolean { return this._isAsync; } getObserver() : Oscar.OscarObserver { return this._observer; } setObserver(observer : Oscar.OscarObserver) : void { this._observer = observer; } isSuccess() : boolean { return this._success; } setSuccess(value : boolean) : void { this._success = value; } getError() : Error { if (this._error !== null && this._error !== undefined) { return this._error; } return new Error('Unknown error'); } setError(value : Error) : void { this._error = value; } getTime() : number { return this._time; } setStart() : void { this._time = new Date().getTime(); } setEnd() : void { this._time = (new Date().getTime()) - this._time; } } }module Oscar { export class Utils { static shuffleArray<T>(a : Array<T>) : void { var n : number; var f : (min : number, max : number) => number; f = (min, max) => { return Math.round(Math.random() * max) + min; }; n = f(a.length, a.length * a.length); while (n >= 0) { var i : number, j : number; var tmp : T; i = f(0, a.length - 1); j = f(0, a.length - 1); tmp = a[i]; a[i] = a[j]; a[j] = tmp; n--; } } } }class Assert { static isTrue(value : boolean) : void { if (!value) { throw new Error('Expected value to be true'); } } static isFalse(value : boolean) : void { if (value) { throw new Error('Expected value to be false'); } } static isNull<T>(value : T) : void { if (value !== null && value !== undefined) { throw new Error('Expected value to be null'); } } static isNotNull<T>(value : T) : void { if (value === null || value === undefined) { throw new Error('Expected value to be not null'); } } static areEqual<T>(expected : T, value : T) : void { if (value !== expected) { throw new Error('Expected ' + expected + ' instead of ' + value); } } static areNotEqual<T>(unexpected : T, value : T) : void { if (value === unexpected) { throw new Error('Unexpected ' + unexpected + ' instead of ' + value); } } static throws(func : () => void) : void { var hasFailed : boolean; hasFailed = false; try { func(); } catch (e) { hasFailed = true; } finally { if (!hasFailed) { throw new Error('Expected function to throw an error'); } } } }interface IOscarObserver { success() : void; fail(error? : Error) : void; }class UnitTestClass { setUp() : void { } tearDown() : void { } }enum TestSuiteOutput { CONSOLE, HTML } declare var process : any; class TestSuite implements Oscar.IOscarObserverListener { private _collected : Array<Oscar.TestClass>; private _totalTests : number; private _successfulTests : number; private _totalRuntime : number; private _output : TestSuiteOutput; private _maxRuntime : number; private _buildFailure : boolean; private _currentTestClass : Oscar.TestClass; private _currentTestClassIndex : number; private _currentTestMethodIndex : number; private _currentAsyncTest : Oscar.TestMethod; private _asyncTimer : any; constructor() { this._collected = new Array<Oscar.TestClass>(); } private _moveToNextTest() : void { this._currentTestMethodIndex++; if (this._currentTestMethodIndex < this._currentTestClass.getMethods().length) { this._runSingleTest(this._currentTestClass.getMethods()[this._currentTestMethodIndex]); } else { this._handleClass(); } } private _runSingleTest(test : Oscar.TestMethod) : void { if (test.isAsync()) { var hasFailed : boolean; this._currentAsyncTest = test; test.setObserver(new Oscar.OscarObserver(this)); try { test.setStart(); this._currentTestClass.getCore().setUp(); test.getCore().call(this._currentTestClass.getCore(), test.getObserver()); hasFailed = false; } catch (e) { try { this._currentTestClass.getCore().tearDown(); } catch (e) { } test.setEnd(); test.setSuccess(false); test.setError(e); hasFailed = true; } finally { if (hasFailed) { test.getObserver().stop(); this._totalTests++; this._totalRuntime += test.getTime(); this._moveToNextTest(); } else { this._asyncTimer = setTimeout(() => { test.getObserver().stop(); this.onFail(new Error('Maximum runtime exceeded')); }, this._maxRuntime); } } } else { try { test.setStart(); this._currentTestClass.getCore().setUp(); test.getCore().call(this._currentTestClass.getCore()); this._currentTestClass.getCore().tearDown(); test.setEnd(); test.setSuccess(true); } catch (e) { try { this._currentTestClass.getCore().tearDown(); } catch (e) { } test.setEnd(); test.setSuccess(false); test.setError(e); } finally { if (test.isSuccess()) { this._successfulTests++; } this._totalTests++; this._totalRuntime += test.getTime(); this._moveToNextTest(); } } } private _handleClass() : void { var methods : Array<Oscar.TestMethod>; this._currentTestClassIndex++; if (this._currentTestClassIndex >= this._collected.length) { this._onRunOver(); return; } this._currentTestClass = this._collected[this._currentTestClassIndex]; methods = this._currentTestClass.getMethods(); if (methods.length < 1) { this._handleClass(); return; } Oscar.Utils.shuffleArray(methods); this._currentTestMethodIndex = 0; this._runSingleTest(methods[0]); } private _onRunOver() : void { var failedTests : number; var sortMethod : (a : Oscar.TestMethod, b : Oscar.TestMethod) => number; failedTests = this._totalTests - this._successfulTests; this._collected.sort( (a, b) => { if (a.getName() > b.getName()) { return 1; } else if (a.getName() < b.getName()) { return -1; } else { return 0; } } ); sortMethod = (a, b) => { if (a.getName() > b.getName()) { return 1; } else if (a.getName() < b.getName()) { return -1; } else { return 0; } }; for (var i = 0; i < this._collected.length; i++) { this._collected[i].getMethods().sort(sortMethod); } if (this._output === TestSuiteOutput.CONSOLE) { console.log('--- Unit testing sum up ---'); if (this._totalRuntime < 1) { console.log('Total: ' + this._totalTests + ' run in less than 1ms.'); } else { console.log('Total: ' + this._totalTests + ' run in ' + this._totalRuntime + 'ms.'); } console.log('Passed tests: ' + this._successfulTests); console.log('Failed tests: ' + failedTests + '\n'); for (var i = 0; i < this._collected.length; i++) { var testClass : Oscar.TestClass; testClass = this._collected[i]; console.log(testClass.getName() + ':'); for (var j = 0; j < testClass.getMethods().length; j++) { var testMethod : Oscar.TestMethod; testMethod = testClass.getMethods()[j]; if (testMethod.isSuccess()) { if (testMethod.getTime() < 1) { console.log('\t' + testMethod.getName() + ' - less than 1ms'); } else { console.log('\t' + testMethod.getName() + ' - ' + testMethod.getTime() + 'ms'); } } else { console.error('\t' + testMethod.getName() + ' FAILED'); console.error('\t\t' + testMethod.getError().toString()); } } } } else { var outcome : string; outcome = '<h1>Unit testing sum up</h1>'; outcome += '<p class="sum-up">Total tests: <span class="total">' + this._totalTests + '</span>. '; outcome += 'Passed tests: <span class="success">' + this._successfulTests + '</span>. '; outcome += 'Failed tests: <span class="fail">' + failedTests + '</span>.</p>'; outcome += '<p>Total: '; if (this._totalRuntime < 1) { outcome += 'less than 1'; } else { outcome += this._totalRuntime; } outcome += 'ms</p>'; outcome += '<ul>'; for (var i = 0; i < this._collected.length; i++) { var testClass : Oscar.TestClass; testClass = this._collected[i]; outcome += '<li class="test-class">' + testClass.getName() + '<ul>'; for (var j = 0; j < testClass.getMethods().length; j++) { var testMethod : Oscar.TestMethod; testMethod = testClass.getMethods()[j]; outcome += '<li class="test-method '; if (testMethod.isSuccess()) { outcome += ' success">' + testMethod.getName() + ' - '; if (testMethod.getTime() < 1) { outcome += 'less than 1'; } else { outcome += testMethod.getTime(); } outcome += 'ms'; } else { outcome += 'fail">' + testMethod.getName() + ' FAILED'; outcome += '<p class="error">' + testMethod.getError().toString() + '</p>'; console.log( '%c' + testMethod.getName() + ' failed with error ' + testMethod.getError().message, 'color: red' ); console.log('%c' + (<any>testMethod.getError()).stack, 'color : red'); } outcome += '</li>'; } outcome += '</ul></li>'; } outcome += '</ul>'; if (document.body !== null && document.body !== undefined) { document.body.innerHTML += outcome; } else { document.documentElement.innerHTML += '<body>' + outcome + '</body>'; } } if (failedTests > 0 && this._buildFailure) { if (process !== null && process !== undefined) { process.exit(1); } } } private _processFailure(error : Error) : void { this._currentAsyncTest.setEnd(); this._currentAsyncTest.setSuccess(false); this._currentAsyncTest.setError(error); this._totalRuntime += this._currentAsyncTest.getTime(); this._totalTests++; this._moveToNextTest(); } add(test : UnitTestClass) : TestSuite { var testClass : Oscar.TestClass; testClass = new Oscar.TestClass(test); for (var name in test) { var prop : any; var l : number; prop = test[name]; l = name.length; if (typeof(prop) === 'function') { if (l > 4) { var suffix : string; suffix = name.substring(l - 4, l).toLowerCase(); if (suffix === 'test') { var testMethod : Oscar.TestMethod; if (l > 9) { var extendedSuffix : string; extendedSuffix = name.substring(l - 9, l - 4).toLowerCase(); if (extendedSuffix === 'async') { testMethod = new Oscar.TestMethod(name, prop, true); } else { testMethod = new Oscar.TestMethod(name, prop, false); } } else { testMethod = new Oscar.TestMethod(name, prop, false); } testClass.addMethod(testMethod); } } } } this._collected.push(testClass); return this; } run(output? : TestSuiteOutput, maxRuntime? : number, buildFailure? : boolean) : void { if (output !== null && output !== undefined) { this._output = output; } else { this._output = TestSuiteOutput.CONSOLE; } if (maxRuntime !== null && maxRuntime !== undefined) { this._maxRuntime = maxRuntime; } else { this._maxRuntime = 30 * 1000; } if (buildFailure !== null && buildFailure !== undefined) { this._buildFailure = buildFailure; } else { this._buildFailure = true; } if (this._collected.length < 1) { throw new Error('No test collected'); } this._totalTests = 0; this._successfulTests = 0; this._totalRuntime = 0; Oscar.Utils.shuffleArray(this._collected); this._currentTestClassIndex = -1; this._handleClass(); } onSuccess() : void { var isTearDownOk : boolean; var error : Error; clearTimeout(this._asyncTimer); this._asyncTimer = null; try { this._currentTestClass.getCore().tearDown(); isTearDownOk = true; } catch (e) { error = e; isTearDownOk = false; } if (!isTearDownOk) { this._processFailure(error); return; } this._currentAsyncTest.setEnd(); this._currentAsyncTest.setSuccess(true); this._successfulTests++; this._totalTests++; this._totalRuntime += this._currentAsyncTest.getTime(); this._moveToNextTest(); } onFail(error? : Error) : void { clearTimeout(this._asyncTimer); this._asyncTimer = null; try { this._currentTestClass.getCore().tearDown(); } catch (e) { } this._processFailure(error); } }