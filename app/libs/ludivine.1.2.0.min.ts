interface Action0 { () : void; } interface Action<T> { (t : T) : void; } interface Action2<T, U> { (t : T, u : U) : void; } interface Action3<T, U, V> { (t : T, u : U, v : V) : void; } interface Action4<T, U, V, W> { (t : T, u : U, v : V, w : W) : void; }class Exception { private _error : any; constructor(msg : string, name : string = 'Exception') { this._error = new Error(msg); this._error.name = name; } getMessage() : string { return this._error.message; } getName() : string { return this._error.name; } getStackTrace() : string { return this._error.stack; } toString() : string { return this._error.name + ': ' + this._error.message; } }interface Func0<U> { () : U; } interface Func<T, U> { (t: T) : U; } interface Func2<T, U, V> { (t : T, u : U) : V; } interface Func3<T, U, V, W> { (t : T, u : U, v : V) : W } interface Func4<T, U, V, W, X> { (t : T, u : U, v : V, w : W) : X }class Guid { static _randomString(length : number) : string { if (length < 1) { return null; } else { var charSet : string = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'; var outcome : string = ''; for (var i = 0; i < length; i++) { var index : number; index = Math.floor(Math.random() * charSet.length); outcome += charSet.charAt(index); } return outcome; } } static newGuid() : string { var outcome : StringBuffer; outcome = new StringBuffer(); outcome.append(Guid._randomString(8)); outcome.append('-'); outcome.append(Guid._randomString(4)); outcome.append('-'); outcome.append(Guid._randomString(4)); outcome.append('-'); outcome.append(Guid._randomString(4)); outcome.append('-'); outcome.append(Guid._randomString(12)); return outcome.toString(); } }class KeyValuePair<T, U> { private _key : T; private _value : U; constructor(key? : T, value? : U) { this._key = key; this._value = value; } getKey() : T { return this._key; } setKey(key : T) : void { this._key = key; } getValue() : U { return this._value; } setValue(value : U) : void { this._value = value; } }enum LogLevel { Debug = 0, Test = 1, Production = 2, Opaque = 3 } class Log { private static _currentLevel : LogLevel = LogLevel.Debug; static setLevel(level : LogLevel) : void { Log._currentLevel = level; } static debug(msg : string) : void { if (this._currentLevel <= LogLevel.Debug) { console.log('DEBUG: ' + msg); } } static inform(msg : string) : void { if (this._currentLevel <= LogLevel.Test) { console.log('%cINFORM: ' + msg, 'color: DeepSkyBlue;'); } } static warn(msg : string) : void { if (this._currentLevel <= LogLevel.Production) { console.log('%cWARN: ' + msg, 'color: orange;'); } } static error(error : Exception) : void { console.error('Error: ' + error.toString()); } }class PeriodicTimer<T> { private _timer : any; constructor(handler : Action<T>, period : number, argument? : T) { this._timer = setInterval( () => { handler(argument); }, period ); } stop() : void { clearInterval(this._timer); } }class StringBuffer { private _content : Array<string>; constructor(first : string = '') { this._content = new Array<string>(); this._content.push(first); } append(s: string) : StringBuffer { this._content.push(s); return this; } toString() : string { var result : string = ''; for (var i = 0; i < this._content.length; i++) { result += this._content[i]; } return result; } }class Timer<T> { private _timer : any; constructor(handler : Action<T>, delay : number, argument? : T) { this._timer = setTimeout( () => { handler(argument); }, delay ); } stop() : void { clearTimeout(this._timer); } }class ArrayList<T> implements IList<T> { private _content : Array<T>; constructor(source? : ICollection<T>) { this._content = new Array<T>(); if (source !== null && source !== undefined) { source.forEach(x => this.add(x)); } } insertAt(index : number, value : T) : void { if (index < 0) { throw new CollectionException('Unbound index'); } if (index >= this._content.length) { this.add(value); } else { var tmp : T; tmp = this._content[index]; this._content[index] = value; this.insertAt(index + 1, tmp); } } add(value : T) : void { this._content.push(value); } getAt(index : number) : T { if (index < 0 || index >= this._content.length) { throw new CollectionException('Unbound index'); } return this._content[index]; } getLength() : number { return this._content.length; } remove(value : T) : void { var a : Array<T>; var size : number; var done : boolean; size = this.getLength(); if (size === 0) { return; } a = new Array<T>(); done = false; for (var i = 0; i < size; i++) { var e : T; e = this._content[i]; if (e !== value) { a.push(e); } else { if (done) { a.push(e); } else { done = true; } } } this._content = a; } removeAt(index : number) : void { var size : number; var a : Array<T>; size = this.getLength(); if (index < 0 || index >= size) { throw new CollectionException('Unbound index'); } a = new Array<T>(); for (var i = 0; i < size; i++) { if (i !== index) { a.push(this.getAt(i)); } } this._content = a; } removeIf(func : Func<T, boolean>) : void { var a : Array<T>; var size : number; size = this.getLength(); if (size === 0) { return; } a = new Array<T>(); for (var i = 0; i < size; i++) { var e : T; e = this._content[i]; if (!func(e)) { a.push(e); } } this._content = a; } orderBy<U>(getter : Func<T, U>) : ISortableCollection<T> { var a : Array<T>; var outcome : ArrayList<T>; outcome = new ArrayList<T>(); if (this.getLength() === 0) { return outcome; } a = new Array<T>(); this.forEach(e => a.push(e)); CollectionUtils.ArrayUtils.sort(a, getter); for (var i = 0; i < a.length; i++) { outcome.add(a[i]); } return outcome; } orderByDesc<U>(getter : Func<T, U>) : ISortableCollection<T> { var a : Array<T>; var outcome : ArrayList<T>; outcome = new ArrayList<T>(); if (this.getLength() === 0) { return outcome; } a = new Array<T>(); this.forEach(e => a.push(e)); CollectionUtils.ArrayUtils.sort(a, getter, false); for (var i = 0; i < a.length; i++) { outcome.add(a[i]); } return outcome; } reverse() : ISortableCollection<T> { var outcome : ArrayList<T>; outcome = new ArrayList<T>(); for (var i = this.getLength() - 1; i >= 0; i--) { outcome.add(this.getAt(i)); } return outcome; } average(getter : Func<T, number>) : number { return CollectionUtils.CollectionHelper.average(this, getter); } exists(selector : Func<T, boolean>) : boolean { return this.find(selector) !== null; } find(selector : Func<T, boolean>) : T { var size : number; size = this.getLength(); for (var i = 0; i < size; i++) { var e : T; e = this.getAt(i); if (selector(e)) { return e; } } return null; } forEach(action : Action<T>) : void { var size : number; size = this.getLength(); for (var i = 0; i < size; i++) { action(this.getAt(i)); } } intersect(collection : ICollection<T>) : ICollection<T> { var outcome : ArrayList<T>; outcome = new ArrayList<T>(); this.forEach( (x) => { if (collection.exists(e => e === x)) { outcome.add(x); } } ); return outcome; } map(action : Func<T, T>) : ICollection<T> { var outcome : ArrayList<T>; outcome = new ArrayList<T>(); this.forEach(e => outcome.add(action(e))); return outcome; } max(getter : Func<T, number>) : T { return CollectionUtils.CollectionHelper.max(this, getter); } min(getter : Func<T, number>) : T { return CollectionUtils.CollectionHelper.min(this, getter); } select(selector : Func<T, boolean>) : ICollection<T> { var outcome : ArrayList<T>; outcome = new ArrayList<T>(); this.forEach( (e) => { if (selector(e)) { outcome.add(e); } } ); return outcome; } sum(getter : Func<T, number>) : number { return CollectionUtils.CollectionHelper.sum(this, getter); } toArray() : Array<T> { return CollectionUtils.CollectionHelper.toArray(this); } toDictionary<K, V>(keyGetter : Func<T, K>, valueGetter : Func<T, V>) : IDictionary<K, V> { return CollectionUtils.CollectionHelper.toDictionary(this, keyGetter, valueGetter); } toList() : IList<T> { return CollectionUtils.CollectionHelper.toList(this); } union(collection : ICollection<T>) : ICollection<T> { var outcome : ArrayList<T>; outcome = new ArrayList<T>(this); collection.forEach( (x) => { if (!this.exists(e => e === x)) { outcome.add(x); } } ); return outcome; } uniq() : ICollection<T> { var outcome : ArrayList<T>; outcome = new ArrayList<T>(); this.forEach( (x) => { if (!outcome.exists(e => e === x)) { outcome.add(x); } } ); return outcome; } }class Dictionary<K, V> implements IDictionary<K, V> { private _content : Array<KeyValuePair<K, V>>; constructor(source? : ICollection<KeyValuePair<K, V>>) { this._content = new Array<KeyValuePair<K, V>>(); if (source !== null && source !== undefined) { source.forEach(x => this.add(x.getKey(), x.getValue())); } } add(key : K, value : V) : void { if (this.hasKey(key)) { throw new CollectionException('Unable to add value: key already exists'); } else { this._content.push(new KeyValuePair<K, V>(key, value)); } } get(key : K) : V { var size : number; size = this._content.length; for (var i = 0; i < size; i++) { var pair : KeyValuePair<K, V>; pair = this._content[i]; if (pair.getKey() === key) { return pair.getValue(); } } throw new CollectionException('No value found for provided key'); } getSize() : number { return this._content.length; } hasKey(key : K) : boolean { var size : number; size = this._content.length; for (var i = 0; i < size; i++) { var pair : KeyValuePair<K, V>; pair = this._content[i]; if (pair.getKey() === key) { return true; } } return false; } remove(key : K) : void { var size : number; var a : Array<KeyValuePair<K, V>>; a = new Array<KeyValuePair<K, V>>(); size = this._content.length; for (var i = 0; i < size; i++) { var pair : KeyValuePair<K, V>; pair = this._content[i]; if (pair.getKey() !== key) { a.push(pair); } } if (a.length === size) { throw new CollectionException('Unable to remove pair: key does not exist'); } this._content = a; } removeIf(func : Func<KeyValuePair<K, V>, boolean>) : void { var size : number; var a : Array<KeyValuePair<K, V>>; a = new Array<KeyValuePair<K, V>>(); size = this._content.length; for (var i = 0; i < size; i++) { var pair : KeyValuePair<K, V>; pair = this._content[i]; if (!func(pair)) { a.push(pair); } } this._content = a; } average(getter : Func<KeyValuePair<K, V>, number>) : number { return CollectionUtils.CollectionHelper.average(this, getter); } exists(selector : Func<KeyValuePair<K, V>, boolean>) : boolean { return this.find(selector) !== null; } find(selector : Func<KeyValuePair<K, V>, boolean>) : KeyValuePair<K, V> { var size : number; size = this._content.length; for (var i = 0; i < size; i++) { var pair : KeyValuePair<K, V>; pair = this._content[i]; if (selector(pair)) { return pair; } } return null; } forEach(action : Action<KeyValuePair<K, V>>) : void { var size : number; size = this._content.length; for (var i = 0; i < size; i++) { action(this._content[i]); } } intersect(collection : ICollection<KeyValuePair<K, V>>) : ICollection<KeyValuePair<K, V>> { var outcome : Dictionary<K, V>; outcome = new Dictionary<K, V>(); this.forEach( (x) => { if (collection.exists(e => (e.getKey() === x.getKey()) && (e.getValue() === x.getValue()))) { outcome.add(x.getKey(), x.getValue()); } } ); return outcome; } map(action : Func<KeyValuePair<K, V>, KeyValuePair<K, V>>) : ICollection<KeyValuePair<K, V>> { var outcome : Dictionary<K, V>; outcome = new Dictionary<K, V>(); this.forEach( (pair) => { var result : KeyValuePair<K, V>; result = action(pair); outcome.add(result.getKey(), result.getValue()); } ); return outcome; } max(getter : Func<KeyValuePair<K, V>, number>) : KeyValuePair<K, V> { return CollectionUtils.CollectionHelper.max(this, getter); } min(getter : Func<KeyValuePair<K, V>, number>) : KeyValuePair<K, V> { return CollectionUtils.CollectionHelper.min(this, getter); } select(selector : Func<KeyValuePair<K, V>, boolean>) : ICollection<KeyValuePair<K, V>> { var outcome : Dictionary<K, V>; outcome = new Dictionary<K, V>(); this.forEach( (pair) => { if (selector(pair)) { outcome.add(pair.getKey(), pair.getValue()); } } ); return outcome; } sum(getter : Func<KeyValuePair<K, V>, number>) : number { return CollectionUtils.CollectionHelper.sum(this, getter); } toArray() : Array<KeyValuePair<K, V>> { return CollectionUtils.CollectionHelper.toArray(this); } toDictionary<A, B>( keyGetter : Func<KeyValuePair<K, V>, A>, valueGetter : Func<KeyValuePair<K, V>, B>) : IDictionary<A, B> { return CollectionUtils.CollectionHelper.toDictionary(this, keyGetter, valueGetter); } toList() : IList<KeyValuePair<K, V>> { return CollectionUtils.CollectionHelper.toList(this); } union(collection : ICollection<KeyValuePair<K, V>>) : ICollection<KeyValuePair<K, V>> { var outcome : Dictionary<K, V>; outcome = new Dictionary<K, V>(this); collection.forEach( (x) => { if (!this.exists(e => (e.getKey() === x.getKey()) && (e.getValue() === x.getValue()))) { outcome.add(x.getKey(), x.getValue()); } } ); return outcome; } uniq() : ICollection<KeyValuePair<K, V>> { return new Dictionary<K, V>(this); } }module LinkedListUtils { export class LinkedListElement<T> { private _content : T; private _next : LinkedListElement<T>; constructor(content? : T) { this._content = content; this._next = null; } getContent() : T { return this._content; } setContent(value : T) : void { this._content = value; } getNext() : LinkedListElement<T> { return this._next; } setNext(value : LinkedListElement<T>) : void { this._next = value; } hasNext() : boolean { return this._next !== null && this._next !== undefined; } } } class LinkedList<T> implements IList<T> { private _head : LinkedListUtils.LinkedListElement<T>; private _tail : LinkedListUtils.LinkedListElement<T>; private _size : number; constructor(source? : ICollection<T>) { this._size = 0; if (source !== null && source !== undefined) { source.forEach(x => this.add(x)); } } insertAt(index : number, value : T) : void { if (index < 0) { throw new CollectionException('Unbound index'); } if (index >= this.getLength()) { this.add(value); } else { var prev : LinkedListUtils.LinkedListElement<T>, current : LinkedListUtils.LinkedListElement<T>; var e : LinkedListUtils.LinkedListElement<T>; e = new LinkedListUtils.LinkedListElement(value); current = this._head; for (var i = 0; i < this.getLength(); i++) { if (i === index) { if (i === 0) { e.setNext(this._head); this._head = e; } else { prev.setNext(e); e.setNext(current); } this._size++; return; } prev = current; current = current.getNext(); } } } add(value : T) : void { var e : LinkedListUtils.LinkedListElement<T>; e = new LinkedListUtils.LinkedListElement(value); if (this.getLength() === 0) { this._head = e; this._tail = e; } else { this._tail.setNext(e); this._tail = e; } this._size++; } getAt(index : number) : T { var e : LinkedListUtils.LinkedListElement<T>; if (index < 0 || index >= this._size) { throw new CollectionException('Unbound index'); } e = this._head; for (var i = 0; i < this.getLength(); i++) { if (i === index) { return e.getContent(); } e = e.getNext(); } } getLength() : number { return this._size; } remove(value : T) : void { var prev : LinkedListUtils.LinkedListElement<T>, current : LinkedListUtils.LinkedListElement<T>; current = this._head; prev = null; for (var i = 0; i < this.getLength(); i++) { if (current.getContent() === value) { if (i === 0) { this._head = current.getNext(); } else { prev.setNext(current.getNext()); } if (i === this.getLength() - 1) { this._tail = prev; } this._size--; return; } prev = current; current = current.getNext(); } } removeAt(index : number) : void { var prev : LinkedListUtils.LinkedListElement<T>, current : LinkedListUtils.LinkedListElement<T>; if (index < 0 || index >= this.getLength()) { throw new CollectionException('Unbound index'); } current = this._head; prev = null; for (var i = 0; i < this.getLength(); i++) { if (i === index) { if (i === 0) { this._head = current.getNext(); } else { prev.setNext(current.getNext()); } if (i === this.getLength() - 1) { this._tail = prev; } this._size--; return; } prev = current; current = current.getNext(); } } removeIf(func : Func<T, boolean>) : void { var prev : LinkedListUtils.LinkedListElement<T>, current : LinkedListUtils.LinkedListElement<T>; prev = null; current = this._head; for (var i = 0; i < this.getLength(); i++) { if (func(current.getContent())) { if (prev === null || prev === undefined) { this._head = current.getNext(); } else { prev.setNext(current.getNext()); } if (i === this.getLength() - 1) { this._tail = prev; } this._size--; } else { prev = current; } current = current.getNext(); } } orderBy<U>(getter : Func<T, U>) : ISortableCollection<T> { var a : Array<T>; var size : number; var outcome : LinkedList<T>; outcome = new LinkedList<T>(); if (this.getLength() === 0) { return outcome; } a = this.toArray(); CollectionUtils.ArrayUtils.sort(a, getter); size = a.length; for (var i = 0; i < size; i++) { outcome.add(a[i]); } return outcome; } orderByDesc<U>(getter : Func<T, U>) : ISortableCollection<T> { var a : Array<T>; var size : number; var outcome : LinkedList<T>; outcome = new LinkedList<T>(); if (this.getLength() === 0) { return outcome; } a = this.toArray(); CollectionUtils.ArrayUtils.sort(a, getter, false); size = a.length; for (var i = 0; i < size; i++) { outcome.add(a[i]); } return outcome; } reverse() : ISortableCollection<T> { var outcome : LinkedList<T>; var a : Array<T>; outcome = new LinkedList<T>(); a = this.toArray(); for (var i = a.length - 1; i >= 0; i--) { outcome.add(a[i]); } return outcome; } average(getter : Func<T, number>) : number { return CollectionUtils.CollectionHelper.average(this, getter); } exists(selector : Func<T, boolean>) : boolean { return this.find(selector) !== null; } find(selector : Func<T, boolean>) : T { var cursor : LinkedListUtils.LinkedListElement<T>; var e : T; if (this.getLength() === 0) { return null; } cursor = this._head; while (cursor.hasNext()) { e = cursor.getContent(); if (selector(e)) { return e; } cursor = cursor.getNext(); } e = cursor.getContent(); if (selector(e)) { return e; } else { return null; } } forEach(action : Action<T>) : void { var cursor : LinkedListUtils.LinkedListElement<T>; if (this.getLength() === 0) { return; } cursor = this._head; while (cursor.hasNext()) { action(cursor.getContent()); cursor = cursor.getNext(); } action(cursor.getContent()); } intersect(collection : ICollection<T>) : ICollection<T> { var outcome : LinkedList<T>; outcome = new LinkedList<T>(); this.forEach( (x) => { if (collection.exists(e => e === x)) { outcome.add(x); } } ); return outcome; } map(action : Func<T, T>) : ICollection<T> { var outcome : LinkedList<T>; outcome = new LinkedList<T>(); this.forEach(x => outcome.add(action(x))); return outcome; } max(getter : Func<T, number>) : T { return CollectionUtils.CollectionHelper.max(this, getter); } min(getter : Func<T, number>) : T { return CollectionUtils.CollectionHelper.min(this, getter); } select(selector : Func<T, boolean>) : ICollection<T> { var outcome : LinkedList<T>; outcome = new LinkedList<T>(); this.forEach( (e) => { if (selector(e)) { outcome.add(e); } } ); return outcome; } sum(getter : Func<T, number>) : number { return CollectionUtils.CollectionHelper.sum(this, getter); } toArray() : Array<T> { return CollectionUtils.CollectionHelper.toArray(this); } toDictionary<K, V>(keyGetter : Func<T, K>, valueGetter : Func<T, V>) : IDictionary<K, V> { return CollectionUtils.CollectionHelper.toDictionary(this, keyGetter, valueGetter); } toList() : IList<T> { return CollectionUtils.CollectionHelper.toList(this); } union(collection : ICollection<T>) : ICollection<T> { var outcome : LinkedList<T>; outcome = new LinkedList<T>(this); collection.forEach( (x) => { if (!this.exists(e => e === x)) { outcome.add(x); } } ); return outcome; } uniq() : ICollection<T> { var outcome : LinkedList<T>; outcome = new LinkedList<T>(); this.forEach( (x) => { if (!outcome.exists(e => e === x)) { outcome.add(x); } } ); return outcome; } }module QueueUtils { export class QueueElement<T> { private _content : T; private _next : QueueElement<T>; constructor(content? : T) { this._content = content; this._next = null; } getContent() : T { return this._content; } setContent(value : T) : void { this._content = value; } getNext() : QueueElement<T> { return this._next; } setNext(value : QueueElement<T>) : void { this._next = value; } hasNext() : boolean { return (this._next !== null && this._next !== undefined); } } } class Queue<T> implements ISortableCollection<T> { private _top : QueueUtils.QueueElement<T>; private _bottom : QueueUtils.QueueElement<T>; private _size : number; constructor(source? : ICollection<T>) { this._size = 0; if (source !== null && source !== undefined) { source.forEach(x => this.push(x)); } } getSize() : number { return this._size; } top() : T { if (this._size === 0) { return null; } else { return this._top.getContent(); } } pop() : T { if (this._size === 0) { return null; } else { var outcome : T; outcome = this._top.getContent(); if (this._size === 1) { this._top = null; this._bottom = null; } else { this._top = this._top.getNext(); } this._size--; return outcome; } } push(value : T) : void { var e : QueueUtils.QueueElement<T>; e = new QueueUtils.QueueElement(value); if (this._size === 0) { this._top = e; this._bottom = e; } else { this._bottom.setNext(e); this._bottom = e; } this._size++; } orderBy<U>(getter : Func<T, U>) : ISortableCollection<T> { var a : Array<T>; var outcome : Queue<T>; outcome = new Queue<T>(); if (this.getSize() === 0) { return outcome; } a = new Array<T>(); this.forEach(e => a.push(e)); CollectionUtils.ArrayUtils.sort(a, getter); for (var i = 0; i < a.length; i++) { outcome.push(a[i]); } return outcome; } orderByDesc<U>(getter : Func<T, U>) : ISortableCollection<T> { var a : Array<T>; var outcome : Queue<T>; outcome = new Queue<T>(); if (this.getSize() === 0) { return outcome; } a = new Array<T>(); this.forEach(e => a.push(e)); CollectionUtils.ArrayUtils.sort(a, getter, false); for (var i = 0; i < a.length; i++) { outcome.push(a[i]); } return outcome; } reverse() : ISortableCollection<T> { var outcome : Queue<T>; var a : Array<T>; outcome = new Queue<T>(); if (this.getSize() === 0) { return outcome; } a = new Array<T>(); this.forEach(x => a.push(x)); for (var i = a.length - 1; i >= 0; i--) { outcome.push(a[i]); } return outcome; } average(getter : Func<T, number>) : number { return CollectionUtils.CollectionHelper.average(this, getter); } exists(selector : Func<T, boolean>) : boolean { return this.find(selector) !== null; } find(selector : Func<T, boolean>) : T { var cursor : QueueUtils.QueueElement<T>; var e : T; if (this.getSize() === 0) { return null; } cursor = this._top; while (cursor.hasNext()) { e = cursor.getContent(); if (selector(e)) { return e; } cursor = cursor.getNext(); } e = cursor.getContent(); if (selector(e)) { return e; } return null; } forEach(action : Action<T>) : void { var cursor : QueueUtils.QueueElement<T>; if (this.getSize() === 0) { return; } cursor = this._top; while (cursor.hasNext()) { action(cursor.getContent()); cursor = cursor.getNext(); } action(cursor.getContent()); } intersect(collection : ICollection<T>) : ICollection<T> { var outcome : Queue<T>; outcome = new Queue<T>(); this.forEach( (x) => { if (collection.exists(e => e === x)) { outcome.push(x); } } ); return outcome; } map(action : Func<T, T>) : ICollection<T> { var outcome : Queue<T>; outcome = new Queue<T>(); this.forEach( (e) => { outcome.push(action(e)); } ); return outcome; } max(getter : Func<T, number>) : T { return CollectionUtils.CollectionHelper.max(this, getter); } min(getter : Func<T, number>) : T { return CollectionUtils.CollectionHelper.min(this, getter); } select(selector : Func<T, boolean>) : ICollection<T> { var outcome : Queue<T>; outcome = new Queue<T>(); this.forEach( (e) => { if (selector(e)) { outcome.push(e); } } ); return outcome; } sum(getter : Func<T, number>) : number { return CollectionUtils.CollectionHelper.sum(this, getter); } toArray() : Array<T> { return CollectionUtils.CollectionHelper.toArray(this); } toDictionary<K, V>(keyGetter : Func<T, K>, valueGetter : Func<T, V>) : IDictionary<K, V> { return CollectionUtils.CollectionHelper.toDictionary(this, keyGetter, valueGetter); } toList() : IList<T> { return CollectionUtils.CollectionHelper.toList(this); } union(collection : ICollection<T>) : ICollection<T> { var outcome : Queue<T>; outcome = new Queue<T>(this); collection.forEach( (x) => { if (!this.exists(e => e === x)) { outcome.push(x); } } ); return outcome; } uniq() : ICollection<T> { var outcome : Queue<T>; outcome = new Queue<T>(); this.forEach( (x) => { if (!outcome.exists(e => e === x)) { outcome.push(x); } } ); return outcome; } }module SortedListUtils { export class SortedListElement<T> { private _content : T; private _next : SortedListElement<T>; constructor(content? : T) { this._content = content; this._next = null; } getContent() : T { return this._content; } setContent(value : T) : void { this._content = value; } getNext() : SortedListElement<T> { return this._next; } setNext(value : SortedListElement<T>) : void { this._next = value; } hasNext() : boolean { return this._next !== null && this._next !== undefined; } } export class SortedListCursor<T> { private _previous : SortedListElement<T>; private _current : SortedListElement<T>; constructor(previous? : SortedListElement<T>, current? : SortedListElement<T>) { this._previous = previous; this._current = current; } getPrevious() : SortedListElement<T> { return this._previous; } setPrevious(value : SortedListElement<T>) : void { this._previous = value; } hasPrevious() : boolean { return this._previous !== null && this._previous !== undefined; } getCurrent() : SortedListElement<T> { return this._current; } setCurrent(value : SortedListElement<T>) : void { this._current = value; } } } class SortedList<A, B> implements IListableCollection<A> { private _head : SortedListUtils.SortedListElement<A>; private _getter : Func<A, B>; private _size : number; private _asc : boolean; constructor(getter : Func<A, B>, ascending? : boolean) { this._getter = getter; this._size = 0; if (ascending !== null && ascending !== undefined) { this._asc = ascending; } else { this._asc = true; } } private _forEach(func : Func<SortedListUtils.SortedListCursor<A>, boolean>) : boolean { var prev : SortedListUtils.SortedListElement<A>, current : SortedListUtils.SortedListElement<A>; if (this.getLength() === 0) { return false; } current = this._head; prev = null; while (current.hasNext()) { if (func(new SortedListUtils.SortedListCursor(prev, current))) { return true; } prev = current; current = current.getNext(); } return func(new SortedListUtils.SortedListCursor(prev, current)); } add(value : A) : void { var e : SortedListUtils.SortedListElement<A>; e = new SortedListUtils.SortedListElement<A>(value); if (this.getLength() === 0) { this._head = e; } else { var success : boolean; var latestCursor : SortedListUtils.SortedListCursor<A>; var comparator : Func2<B, B, boolean>; if (this._asc) { comparator = (a, b) => { return a < b; }; } else { comparator = (a, b) => { return a > b; }; } success = this._forEach( (cursor) => { var current : SortedListUtils.SortedListElement<A>; current = cursor.getCurrent(); latestCursor = cursor; if (comparator(this._getter(value), this._getter(current.getContent()))) { if (cursor.hasPrevious()) { cursor.getPrevious().setNext(e); } else { this._head = e; } e.setNext(current); return true; } else { return false; } } ); if (!success) { latestCursor.getCurrent().setNext(e); } } this._size++; } getAt(index : number) : A { var outcome : A; var i : number; if (index < 0 || index >= this.getLength()) { throw new CollectionException('Unbound index'); } i = 0; this._forEach( (cursor) => { if (i === index) { outcome = cursor.getCurrent().getContent(); return true; } else { i++; return false; } } ); return outcome; } getLength() : number { return this._size; } remove(value : A) : void { var done : boolean; done = this._forEach( (cursor) => { if (cursor.getCurrent().getContent() === value) { if (cursor.hasPrevious()) { cursor.getPrevious().setNext(cursor.getCurrent().getNext()); } else { this._head = cursor.getCurrent().getNext(); } return true; } else { return false; } } ); if (done) { this._size--; } } removeAt(index : number) : void { var i : number; if (index < 0 || index >= this.getLength()) { throw new CollectionException('Unbound index'); } i = 0; this._forEach( (cursor) => { if (i === index) { var e : SortedListUtils.SortedListElement<A>; e = cursor.getCurrent().getNext(); if (cursor.hasPrevious()) { cursor.getPrevious().setNext(e); } else { this._head = e; } return true; } i++; } ); this._size--; } removeIf(func : Func<A, boolean>) : void { var prev : SortedListUtils.SortedListElement<A>, current : SortedListUtils.SortedListElement<A>; var size : number; size = this.getLength(); prev = null; current = this._head; for (var i = 0; i < size; i++) { if (func(current.getContent())) { if (prev !== null && prev !== undefined) { prev.setNext(current.getNext()); } else { this._head = current.getNext(); } this._size--; } else { prev = current; } current = current.getNext(); } } orderBy<C>(getter : Func<A, C>) : ISortableCollection<A> { var outcome : SortedList<A, C>; outcome = new SortedList<A, C>(getter); this.forEach(e => outcome.add(e)); return outcome; } orderByDesc<C>(getter : Func<A, C>) : ISortableCollection<A> { var outcome : SortedList<A, C>; outcome = new SortedList<A, C>(getter, false); this.forEach(e => outcome.add(e)); return outcome; } reverse() : ISortableCollection<A> { var outcome : SortedList<A, B>; outcome = new SortedList<A, B>(this._getter, !this._asc); this.forEach(e => outcome.add(e)); return outcome; } average(getter : Func<A, number>) : number { return CollectionUtils.CollectionHelper.average(this, getter); } exists(selector : Func<A, boolean>) : boolean { return this.find(selector) !== null; } find(selector : Func<A, boolean>) : A { var outcome : A; outcome = null; this._forEach( (cursor) => { var content : A; content = cursor.getCurrent().getContent(); if (selector(content)) { outcome = content; return true; } return false; } ); return outcome; } forEach(action : Action<A>) : void { this._forEach( (cursor) => { action(cursor.getCurrent().getContent()); return false; } ); } intersect(collection : ICollection<A>) : ICollection<A> { var outcome : SortedList<A, B>; outcome = new SortedList<A, B>(this._getter, this._asc); this.forEach( (x) => { if (collection.exists(e => e === x)) { outcome.add(x); } } ); return outcome; } map(action : Func<A, A>) : ICollection<A> { var outcome : SortedList<A, B>; outcome = new SortedList<A, B>(this._getter, this._asc); this.forEach( (e) => { outcome.add(action(e)); } ); return outcome; } max(getter : Func<A, number>) : A { return CollectionUtils.CollectionHelper.max(this, getter); } min(getter : Func<A, number>) : A { return CollectionUtils.CollectionHelper.min(this, getter); } select(selector : Func<A, boolean>) : ICollection<A> { var outcome : SortedList<A, B>; outcome = new SortedList<A, B>(this._getter, this._asc); this.forEach( (e) => { if (selector(e)) { outcome.add(e); } } ); return outcome; } sum(getter : Func<A, number>) : number { return CollectionUtils.CollectionHelper.sum(this, getter); } toArray() : Array<A> { return CollectionUtils.CollectionHelper.toArray(this); } toDictionary<K, V>(keyGetter : Func<A, K>, valueGetter : Func<A, V>) : IDictionary<K, V> { return CollectionUtils.CollectionHelper.toDictionary(this, keyGetter, valueGetter); } toList() : IList<A> { return CollectionUtils.CollectionHelper.toList(this); } union(collection : ICollection<A>) : ICollection<A> { var outcome : SortedList<A, B>; outcome = new SortedList<A, B>(this._getter, this._asc); this.forEach(x => outcome.add(x)); collection.forEach( (x) => { if (!this.exists(e => e === x)) { outcome.add(x); } } ); return outcome; } uniq() : ICollection<A> { var outcome : SortedList<A, B>; outcome = new SortedList<A, B>(this._getter, this._asc); this.forEach( (x) => { if (!outcome.exists(e => e === x)) { outcome.add(x); } } ); return outcome; } }module StackUtils { export class StackElement<T> { private _prev : StackElement<T>; private _content : T; constructor(content? : T) { this._content = content; this._prev = null; } getContent() : T { return this._content; } setContent(value : T) : void { this._content = value; } getPrev() : StackElement<T> { return this._prev; } setPrev(value : StackElement<T>) : void { this._prev = value; } hasPrev() : boolean { return this._prev !== null && this._prev !== undefined; } } } class Stack<T> implements ISortableCollection<T> { private _tail : StackUtils.StackElement<T>; private _size : number; constructor(source? : ICollection<T>) { this._size = 0; if (source !== null && source !== undefined) { source.forEach(x => this.push(x)); } } private _forEachInversed(action : Action<T>) : void { var a : Array<T>; var cursor : StackUtils.StackElement<T>; if (this.getSize() === 0) { return; } a = new Array<T>(); cursor = this._tail; while (cursor.hasPrev()) { a.push(cursor.getContent()); cursor = cursor.getPrev(); } a.push(cursor.getContent()); for (var i = a.length - 1; i >= 0; i--) { action(a[i]); } } getSize() : number { return this._size; } top() : T { if (this.getSize() === 0) { return null; } else { return this._tail.getContent(); } } pop() : T { if (this.getSize() === 0) { return null; } else { var e : T; e = this._tail.getContent(); this._size--; this._tail = this._tail.getPrev(); return e; } } push(value : T) : void { var e : StackUtils.StackElement<T>; e = new StackUtils.StackElement(value); if (this.getSize() === 0) { this._tail = e; } else { e.setPrev(this._tail); this._tail = e; } this._size++; } orderBy<U>(getter : Func<T, U>) : ISortableCollection<T> { var outcome : Stack<T>; var a : Array<T>; outcome = new Stack<T>(); if (this.getSize() === 0) { return outcome; } a = new Array<T>(); this.forEach(e => a.push(e)); CollectionUtils.ArrayUtils.sort(a, getter); for (var i = a.length - 1; i >= 0; i--) { outcome.push(a[i]); } return outcome; } orderByDesc<U>(getter : Func<T, U>) : ISortableCollection<T> { var outcome : Stack<T>; var a : Array<T>; outcome = new Stack<T>(); if (this.getSize() === 0) { return outcome; } a = new Array<T>(); this.forEach(e => a.push(e)); CollectionUtils.ArrayUtils.sort(a, getter); for (var i = 0; i < a.length; i++) { outcome.push(a[i]); } return outcome; } reverse() : ISortableCollection<T> { var outcome : Stack<T>; outcome = new Stack<T>(); this.forEach(e => outcome.push(e)); return outcome; } average(getter : Func<T, number>) : number { return CollectionUtils.CollectionHelper.average(this, getter); } exists(selector : Func<T, boolean>) : boolean { return this.find(selector) !== null; } find(selector : Func<T, boolean>) : T { var cursor : StackUtils.StackElement<T>; var e : T; if (this.getSize() === 0) { return null; } cursor = this._tail; while (cursor.hasPrev()) { e = cursor.getContent(); if (selector(e)) { return e; } cursor = cursor.getPrev(); } e = cursor.getContent(); if (selector(e)) { return e; } else { return null; } } forEach(action : Action<T>) : void { var cursor : StackUtils.StackElement<T>; if (this.getSize() === 0) { return; } cursor = this._tail; while (cursor.hasPrev()) { action(cursor.getContent()); cursor = cursor.getPrev(); } action(cursor.getContent()); } intersect(collection : ICollection<T>) : ICollection<T> { var outcome : Stack<T>; outcome = new Stack<T>(); this._forEachInversed( (x) => { if (collection.exists(e => e === x)) { outcome.push(x); } } ); return outcome; } map(action : Func<T, T>) : ICollection<T> { var outcome : Stack<T>; outcome = new Stack<T>(); this._forEachInversed(e => outcome.push(action(e))); return outcome; } max(getter : Func<T, number>) : T { return CollectionUtils.CollectionHelper.max(this, getter); } min(getter : Func<T, number>) : T { return CollectionUtils.CollectionHelper.min(this, getter); } select(selector : Func<T, boolean>) : ICollection<T> { var outcome : Stack<T>; outcome = new Stack<T>(); this._forEachInversed( (e) => { if (selector(e)) { outcome.push(e); } } ); return outcome; } sum(getter : Func<T, number>) : number { return CollectionUtils.CollectionHelper.sum(this, getter); } toArray() : Array<T> { return CollectionUtils.CollectionHelper.toArray(this); } toDictionary<K, V>(keyGetter : Func<T, K>, valueGetter : Func<T, V>) : IDictionary<K, V> { return CollectionUtils.CollectionHelper.toDictionary(this, keyGetter, valueGetter); } toList() : IList<T> { return CollectionUtils.CollectionHelper.toList(this); } union(collection : ICollection<T>) : ICollection<T> { var outcome : Stack<T>; outcome = new Stack<T>(); this._forEachInversed(x => outcome.push(x)); collection.forEach( (x) => { if (!this.exists(e => e === x)) { outcome.push(x); } } ); return outcome; } uniq() : ICollection<T> { var outcome : Stack<T>; outcome = new Stack<T>(); this._forEachInversed( (x) => { if (!outcome.exists(e => e === x)) { outcome.push(x); } } ); return outcome; } }interface ICollection<T> { average(getter : Func<T, number>) : number; exists(selector : Func<T, boolean>) : boolean; find(selector : Func<T, boolean>) : T; forEach(action : Action<T>) : void; intersect(collection : ICollection<T>) : ICollection<T>; map(action : Func<T, T>) : ICollection<T>; max(getter : Func<T, number>) : T; min(getter : Func<T, number>) : T; select(selector : Func<T, boolean>) : ICollection<T>; sum(getter : Func<T, number>) : number; toArray() : Array<T>; toDictionary<K, V>(keyGetter : Func<T, K>, valueGetter : Func<T, V>) : IDictionary<K, V>; toList() : IList<T>; union(collection : ICollection<T>) : ICollection<T>; uniq() : ICollection<T>; }interface IDictionary<K, V> extends ICollection<KeyValuePair<K, V>> { add(key : K, value : V) : void; get(key : K) : V; getSize() : number; hasKey(key : K) : boolean; remove(key : K) : void; removeIf(func : Func<KeyValuePair<K, V>, boolean>) : void; }interface IList<T> extends IListableCollection<T> { insertAt(index : number, value : T) : void; }interface IListableCollection<T> extends ISortableCollection<T> { add(value : T) : void; getAt(index : number) : T; getLength() : number; remove(value : T) : void; removeAt(index : number) : void; removeIf(func : Func<T, boolean>) : void; }interface ISortableCollection<T> extends ICollection<T> { orderBy<U>(getter : Func<T, U>) : ISortableCollection<T>; orderByDesc<U>(getter : Func<T, U>) : ISortableCollection<T>; reverse() : ISortableCollection<T>; }module CollectionUtils { export class ArrayUtils { private static _swap<T>(source : Array<T>, i : number, j : number) : void { var tmp : T; tmp = source[i]; source[i] = source[j]; source[j] = tmp; } private static _partition<T, U>( source : Array<T>, getter : Func<T, U>, comparator : Func2<U, U, boolean>, first : number, last : number, pivot : number) : number { var j : number; var pivotValue : U; j = pivot; pivotValue = getter(source[pivot]); for (var i = first; i <= last; i++) { var value : U; value = getter(source[i]); if (comparator(value, pivotValue)) { if (j < i) { ArrayUtils._swap(source, j + 1, i); ArrayUtils._swap(source, j, j + 1); j++; } } else { if (i < j) { ArrayUtils._swap(source, i, j); j = i; } } } return j; } private static _sort<T, U>( source : Array<T>, getter : Func<T, U>, comparator : Func2<U, U, boolean>, first : number, last : number) : void { if (first < last) { var pivot : number; pivot = Math.round(Math.random() * (last - first)); pivot = ArrayUtils._partition(source, getter, comparator, first, last, pivot); ArrayUtils._sort(source, getter, comparator, first, pivot - 1); ArrayUtils._sort(source, getter, comparator, pivot + 1, last); } } static sort<T, U>(source : Array<T>, getter : Func<T, U>, asc : boolean = true) : void { var comparator : Func2<U, U, boolean>; if (source.length === 0) { return; } if (asc) { comparator = (a, b) => { return a <= b; }; } else { comparator = (a, b) => { return a >= b; }; } ArrayUtils._sort(source, getter, comparator, 0, source.length - 1); } } }class CollectionException extends Exception { constructor(msg : string) { super(msg, 'CollectionException'); } }module CollectionUtils { export class CollectionHelper { private static _extrema<T>( source : ICollection<T>, getter : Func<T, number>, comparator : Func2<number, number, boolean>) : T { var outcome : T; var extrema : number; var isFirstTime : boolean; isFirstTime = true; source.forEach( (e) => { if (isFirstTime) { isFirstTime = false; outcome = e; extrema = getter(e); } else { var value : number; value = getter(e); if (comparator(value, extrema)) { outcome = e; extrema = value; } } } ); if (isFirstTime) { return null; } else { return outcome; } } static average<T>(source : ICollection<T>, getter : Func<T, number>) : number { var outcome : number; var size : number; size = 0; outcome = 0; source.forEach( (x) => { outcome += getter(x); size++; } ); if (size === 0) { return 0; } else { return outcome / size; } } static max<T>(source : ICollection<T>, getter : Func<T, number>) : T { return CollectionHelper._extrema(source, getter, (a, b) => a > b); } static min<T>(source : ICollection<T>, getter : Func<T, number>) : T { return CollectionHelper._extrema(source, getter, (a, b) => a < b); } static sum<T>(source : ICollection<T>, getter : Func<T, number>) : number { var outcome : number; outcome = 0; source.forEach(x => outcome += getter(x)); return outcome; } static toArray<T>(source : ICollection<T>) : Array<T> { var outcome : Array<T>; outcome = new Array<T>(); source.forEach(x => outcome.push(x)); return outcome; } static toDictionary<T, K, V>( source : ICollection<T>, keyGetter : Func<T, K>, valueGetter : Func<T, V>) : IDictionary<K, V> { var outcome : IDictionary<K, V>; outcome = new Dictionary<K, V>(); source.forEach(x => outcome.add(keyGetter(x), valueGetter(x))); return outcome; } static toList<T>(source : ICollection<T>) : IList<T> { return new ArrayList<T>(source); } } }